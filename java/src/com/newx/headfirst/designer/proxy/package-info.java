/**
 * Created by xuzhijian on 2018/2/28 0028.
 * 代理模式：
 *   目的提供替身，控制对对象的访问。
 *   和适配器比较，都挡在其他对象的前面，不同的是适配器要改变对象适配的接口，代理实现相同的接口（特例：保护代理）
 *
 *   让客户使用代理的方法：提供一个工厂，进行包装后再返回。
 *
 *   远程代理：通过代理来操作远程对象 （调用代理的方法 -> 代理去调用实际对象的方法
 *                                       -> 实际对象返回数据给代理 -> 代理把数据给调用者）
 *             所以伴随很多的网络操作和IO操作，所以要处理远程异常
 *   虚拟代理：（和装饰者模式比较，代理模式将客户和目标对象解耦了）例子：大图片加载，先显示加载中，
 *             等图片加载完，再显示真正的图片，此时创建了真正的对象（装饰者包装对象）。
 *                -> 加入行为，在创建对象的时候做一些事情
 *                -> 用于创建开销大的对象，创建中先用代理显示，创建好后，把请求直接委托给对象。
 *
 *   缓存代理：-> 功能：为开销大的运算结果提供暂时存储，它也允许多个客户共享结果，来减少计算和网络延迟
 *                应用：web服务器代理，内容管理和出版系统。
 *
 *   防火墙代理：-> 功能：控制网络资源的访问，保护对象免受恶意攻击。
 *                  应用：
 *
 *   智能引用代理：-> 功能：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数
 *                    应用：JVM 垃圾回收？
 *
 *   同步代理：-> 功能：多线程的情况下为主题提供安全的访问。
 *                应用：
 *
 *   复杂隐藏代理：-> 功能：
 *                    应用：
 *
 *   写入时复制代理：-> 功能：
 *                      应用：
 */
package com.newx.headfirst.designer.proxy;