/**
 * Created by xuzhijian on 2018/3/5 0005.
 * 垃圾收集器和内存分配策略
 *
 * 可达性分析算法 -> 解决循环引用问题，但是内存泄漏还是存在：
 *  GCRoots: 1.虚拟机栈(栈帧中的本地变量表)中引用对象;
 *           2.方法区中类静态属性引用的对象;
 *           3.方法区中常量引用的对象;
 *           4.本地方法JNI(即一般说的Native方法)引用的对象。
 *  强软弱虚引用的回收机制以及用法。
 *
 * 回收方法区(储存类的) -> 大量使用反射、动态代理、CGLib等ByteCode框架、      -> 后来ButterKnife不损耗性能的原因？
 *                         动态生成JSP和OSGi这类频繁自定义ClassLoader的场景
 *                         需要虚拟机具备类卸载功能，来保证永久代不会溢出。
 *
 * 标记-清除算法：
 *    方法：1.标记所有需要回收的对象; 2.标记完成后统一回收所有被标记的对象。
 *    不足：1.时间上，标记和清除过程的效率都不高; 2.空间上，标记清除会产生大量的内存碎片
 *
 * 复制算法： -> 解决效率问题
 *    方法：把内存划分为相等大小的两块，用完了，把存活着的对象复制到另一块上(不是类似复制粘贴)，
 *          然把之前用完那块的内存空间一次清理掉。
 *    不足：代价太大，牺牲了一半的内存，适用于新生代。
 *
 * 标记-整理算法：
 *    方法：与标记-清除一样，但是后续是把存货的对象往一端移动，清除存活对象边界外的内存 -> 解决碎片化问题
 *
 * 分代收集算法：
 *    新生代：复制算法       -> 对象优先在新生代分配
 *    老年代：标记-清除/整理 -> 1.大对象直接进入老年代 (static 强引用大对象很危险,老年代难GC，并且采用复制算法，耗空间 -> 卡)
 *                              2.长期存活的对象进入老年代
 *                               (Eden区的对象经过第一次MinorGC进入Survivor,年龄设置为1，在不断MinorGC后，
 *                                年龄大于阈值，就进入老年代，默认15岁，可用-XX:MaxTenuringThreshold设置)
 *                              3.Survivor空间中相同年龄的所有对象大于Survivor空间的一半，年龄大于或等于该年龄的进入老年代。
 *
 *
 */
package com.newx.jvm.ep3;